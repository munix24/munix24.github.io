<!DOCTYPE html>
<html lang="en">
<head>
    <!-- <meta charset="ASCII"> -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SHA-256 Hash Breakdown</title>
    <script src="../scripts/script.js"></script> 
    <link rel="stylesheet" href="../styles/style.css">
    <style>
        textarea {
            font-family: 'Arial, sans-serif';
            font-size: 16px; 
            background-color: #222;
            color: #fff;
            text-align: center;
        }

        /* color 2nd & 6th col as green to signify new value */
        #roundsLogTable tr:not(:nth-of-type(1)) td:nth-child(2),
        #roundsLogTable tr:not(:nth-of-type(1)) td:nth-child(6) {
            background-color: #333;
            color: #00ff9d;
            font-weight: bold;
        }

        /* color 5nd & 9th col as red to signify getting changed */
        #roundsLogTable td:nth-child(5),
        #roundsLogTable td:nth-child(9) {
            background-color: #333;
            color: #ff1100;
            font-weight: bold;
        }

        .truncate-cell {
            max-width: 570px;      /* 256Unt is max 256/3.3 ~= 78 characters * 10 px per char */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .monospace-cell {
            font-family: monospace;
            font-size: 16px;
            white-space: pre;
            vertical-align: middle; /* or top / bottom */
            text-align: left;       /* or center / right */
        }

        .cell-content {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            height: 100%;
        }

        .top, .bottom {
            text-align: center;
        }
    </style>
</head>
<body>
    <h2>SHA-256 Hash Generator</h2>

    <input type="text" id="input" placeholder="Enter text here" oninput="generateHash()" value="" size="64">
    <button id="add0ToInputButton" onclick="add0ToInput()">+0</button>
    <button id="hashInputButton" onclick="inputHash()">Hash Input</button>
    <button id="resetInputButton" onclick="inputReset()">Reset</button>
    <strong style="margin-left: 0.5em;">Input Bytes:</strong> <span id="lengthDisplay" style="display:inline-block; min-width:3ch; text-align:right;">0</span>
    <strong style="margin-left: 0.5em;">Input Bits:</strong> <span id="bitLengthDisplay" style="display:inline-block; min-width:3ch; text-align:right;">0</span>
    <br></br>

    <table id="messageTable" border="1" cellpadding="4" cellspacing="0" style="margin: auto; text-align: center; color: white; border-collapse: collapse;">
        <thead>
            <tr>
                <th>inputBinary</th>
                <th>preprocess</th>
                <th>message</th>
                <th>process</th>
                <th>W (4-byte longs)</th>
                <th>W formula</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    <textarea id="inputBinary" rows="16" cols="35" placeholder="input Binary"></textarea>
                    <br></br>
                    <button id="inputIncrement" onclick="bitFunctions.incrementInput()">+</button>
                    <button id="inputDecrement" onclick="bitFunctions.decrementInput()">-</button>
                    <button id="inputBitShiftLeft" onclick="bitFunctions.shiftInputLeft1()"><<<+1</button>
                    <button id="inputBitShiftRight" onclick="bitFunctions.shiftInputRight1()">>>></button>
                </td>
                <td>
                    preprocess input into message:
                    <p></p>
                    <label><input type="checkbox" id="append1Bit" oninput="generateHash()" checked>append a single '1' bit</label>
                    <p></p>
                    <label><input type="checkbox" id="fill0Bit" oninput="generateHash()" checked>fill with '0' bits</label>
                    <p></p>
                    <label><input type="checkbox" id="appendLength" oninput="generateHash()" checked>append message length L bits</label>
                    <p></p>
                    <label><input type="checkbox" id="initWorkingVars" oninput="generateHash()" checked>init working variables</label>
                </td>
                <td>
                    <textarea id="messageBinaryPreprocessed" rows="21" cols="35" placeholder="message Preprocessed"></textarea>
                </td>
                <td style="width: 100px;height: 300px;padding: 0;">
                    <div class="cell-content">
                        <span class="top">
                            message in 16 
                            4-byte longs
                        </span>
                        <span class="bottom">
                            17:64
                            based on first 16
                        </span>
                    </div>
                </td>
                <td>
                    <textarea id="messageW" rows="21" cols="12" placeholder="W" style="text-align:right;"></textarea>
                </td>
                <td>
                    <textarea id="messageWFormula" rows="21" cols="12" placeholder="W" style="text-align:right;"></textarea>
                </td>
            </tr>
        </tbody>
    </table>
<!--     
    <table id="hashTable" cellpadding="11" cellspacing="0" style="margin: auto; text-align: center; color: white;">
        <thead>
            <tr>
                <td>
                    <strong>SHA-256 Hash (Manual):</strong>
                    <br></br>
                    <span id="manualSHA"></span> <button onclick="copyHash('manualSHA', 'manualStatus')">Copy</button><span id="manualStatus" style="margin-left: 10px;"></span>
                </td>
                <td>
                    <span id="cryptoSHAContainer" style="visibility: hidden;">
                        <strong>SHA-256 Hash (Web Crypto API):</strong>
                        <br></br>
                        <span id="cryptoSHA"></span> <button onclick="copyHash('cryptoSHA', 'cryptoStatus')">Copy</button><span id="cryptoStatus" style="margin-left: 10px;"></span>
                    </span>
                </td>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td colspan="2">
                    <label><input type="checkbox" id="showCrypto" oninput="toggleVisibilityByID('cryptoSHAContainer', this.checked)">Show Web Crypto API</label>
                </td>
            </tr>
        </tbody>
    </table>
    -->

    <table id="checkboxesTable" cellpadding="11" cellspacing="0" style="width: 100%; margin: 10px auto 0 auto; table-layout: fixed; color: white;">
        <tbody>
            <tr>
                <td style="vertical-align: top;">
                    <label><input id="incrementCheckbox" type="checkbox" oninput="toggleDisplayByID('incrementContainer', this.checked)" checked>Show Increments in </label>
                    <select id="displayFormat" oninput="generateHash()">
                        <option value="hex">Hex</option>
                        <option value="binary" selected>Binary</option>
                        <option value="256UInt">256UInt</option>
                    </select> 
                    <label><input id="APICheckbox" type="checkbox" oninput="toggleDisplayTableIDCol('incrementTable', 4, this.checked)">Show API Hash</label>
                </td>
                <td style="vertical-align: top;">
                    <label><input id="roundsShowCheckbox" type="checkbox" oninput="toggleDisplayByID('roundsContainer', this.checked)">Show 64 Rounds Working Variables</label>
                    <label><input id="roundsCollapseCheckbox" type="checkbox" oninput="generateHash()" checked>Collapse Rounds 5-60</label>
                </td>
            </tr>
        </tbody>
    </table>

    <table id="outputsTable" cellpadding="11" cellspacing="0" style="margin: auto; text-align: center; color: white;">
        <tbody>
            <tr>
                <td style="vertical-align: top;">
                    <span id="incrementContainer" style="display: none;">
                        <!-- <p><strong>Incremental Hashes:</strong></p> -->
                        <table id="incrementTable" border="1" cellpadding="4" cellspacing="0" style="margin: auto; text-align: left; color: white; border-collapse: collapse;">
                            <thead>
                                <tr>
                                    <th>Input</th>
                                    <th>Diffs</th>
                                    <th>Manual Hash</th>
                                    <span id="cryptoSHAContainer" style="visibility: hidden;">
                                    <th>API Hash</th>
                                    </span>
                                </tr>
                            </thead>
                            <tbody>

                            </tbody>
                        </table>
                    </span>
                </td>
                <td style="vertical-align: top;">
                    <span id="roundsContainer" style="display: none;">
                        <!-- <p><strong>64 Rounds Working Variables:</strong></p> -->
                        <table id="roundsLogTable" border="1" cellpadding="4" cellspacing="0" style="margin: auto; text-align: left; color: white; border-collapse: collapse;">
                            <thead>
                                <tr>
                                    <th>Round</th>
                                    <th>a</th>
                                    <th>b</th>
                                    <th>c</th>
                                    <th>d</th>
                                    <th>e</th>
                                    <th>f</th>
                                    <th>g</th>
                                    <th>h</th>
                                    <th>e - d</th>
                                    <th>a - h</th>
                                    <th>T</th>
                                </tr>
                            </thead>
                            <tbody>
                                
                            </tbody>
                        </table>
                    </span>
                </td>
            </tr>
        </tbody>
    </table>
</body>

<script>
    // checkbox that is always checked that checks all checkboxes
    // TODO: calculate api hash to hidden element even if unchecked?
    // TODO: implement W formula to show which values its based on
    // TODO: show that main avalanche and irreversible-ness comes from initial processing of message schedule array, W 

    "use strict";
    // first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311
    const k = [
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    ];

    // first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
    const initialPrimes = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]

    // global random sequence state
    let randomSequenceIndex = 0;  // stays in memory until page reload

    function inputReset(){
        document.getElementById('input').value = '';
        generateHash();
    }

    async function inputHash(){
        let val;
        val = document.getElementById('input').value;

        // convert index to next hex in sequence
        // val = randomSequenceIndex === 0 ? "" : randomSequenceIndex - 1;
        // randomSequenceIndex++; // advance sequence for next click

        const hash = await apiSHA256(val);
        const hashHexStr = formatByteArray(hash, 'hex');

        document.getElementById('input').value = hashHexStr;
        generateHash();
    }
    
    function add0ToInput() {
        const inputElement = document.getElementById('input');
        inputElement.value += '\0';                           // Option 1: using escape sequence
        // inputElement.value += String.fromCharCode(0);      // Option 2: using String.fromCharCode
        
        generateHash();
    }

    function copyHash(id, statusId) {
        const text = document.getElementById(id).innerText;
        navigator.clipboard.writeText(text).then(() => {
            const status = document.getElementById(statusId);
            if (status) {
                status.textContent = "Copied!";
                setTimeout(() => status.textContent = "", 2000); // Clear after 2 seconds
            }
        });
    }

    // Convert hex string to Uint8Array
    function hexStrToByteArray(hexStr) {
        const bytes = new Uint8Array(hexStr.length / 2);
        for (let i = 0; i < bytes.length; i++) {
            bytes[i] = parseInt(hexStr.substr(i * 2, 2), 16);
        }
        return bytes;
    }

    // Count number of 1 bits in a number (Brian Kernighanâ€™s algorithm)
    function countBits(n) {
        let count = 0;
        while (n) {
            n &= (n - 1);
            count++;
        }
        return count;
    }

    // Compute bit difference count and bit string between two byte arrays
    function bitDifference(arr1, arr2) {
        if (!Array.isArray(arr1) || !Array.isArray(arr2) || arr1.length !== arr2.length) {
            throw new Error("Both inputs must be arrays of equal length");
        }

        const diffArray = [];
        let totalDiffBits = 0;

        for (let i = 0; i < arr1.length; i++) {
            const diff = arr1[i] ^ arr2[i];
            diffArray.push(diff);
            totalDiffBits += countBits(diff);
        }

        return {
            diffArray,        // Plain JavaScript array of byte-wise XORs
            totalDiffBits     // Total number of differing bits
        };
    }

    function printIntArray(intArray) {
        return intArray.map(l => l.toString(10).padStart(10, '0')).join('\n');
    }

    function printIntArrayAsBinaryStr(intArray) {
        return Array.from(intArray)
            .map(val => {
                const bin = val.toString(2).padStart(32, '0');
                return bin.match(/.{1,8}/g).join(' ');
            })
            .join('\n');
    }

    function intArrayToStringArray(intArray) {
        return intArray.map(l => l.toString(10).padStart(10, '0'));
    }

    function byteArrayToBinaryStr(bytesArray, joinStr = ' ') {
        return bytesArray.map(b => b.toString(2).padStart(8, '0')).join(joinStr);
    }

    function byteArrayToHexStr(bytesArray) {
        return bytesArray.map(b => b.toString(16).padStart(2, '0')).join('');   
    }

    function int32ArrayToBytesArray(intArray) {
        const bytes = [];
        for (const num of intArray) {
            bytes.push((num >>> 24) & 0xFF);
            bytes.push((num >>> 16) & 0xFF);
            bytes.push((num >>> 8) & 0xFF);
            bytes.push(num & 0xFF);
        }
        return bytes;
    }

    function byteArrayToBigDecimal(bytes) {
        let result = 0n;
        for (const byte of bytes) {
            result = (result << 8n) + BigInt(byte);
        }
        return result.toString().padStart(78, '0');  // pad for easier comparison. 256UInt is max 256 / log(10)/log(2) ~= 256 / 3.3 ~= 77.01 round up
    }

    function formatByteArray(bytes, format = 'hex') {
        if (!bytes || typeof bytes[Symbol.iterator] !== 'function' || bytes.length === 0) {
            return '';  // or return some default/error string
        }

        switch (format) {
            case 'hex':
                return byteArrayToHexStr(bytes);
            case 'binary':
                return byteArrayToBinaryStr(bytes, ' ');
            case '256UInt':
                return byteArrayToBigDecimal(bytes);
            default:
                return '';
        }
    }

    function createRow(rowHeader, tdContentArray, tdClassName = "") {
        const row = document.createElement("tr");

        const headerCell = document.createElement("td");
        headerCell.textContent = rowHeader.toString();
        row.appendChild(headerCell);

        // output array values
        for (let i = 0; i < tdContentArray.length; i++) {
            let cell = document.createElement("td");
            cell.textContent = tdContentArray[i];
            cell.className = "monospace-cell truncate-cell";

            row.appendChild(cell);
        }

        return row;
    };

    function rightRotate(value, amount) {
        var ret1=(value >>> amount);
        var ret2=(value << (32 - amount));
        var ret3=ret1 | ret2;
        return (value >>> amount) | (value << (32 - amount));
    }

    const bitFunctions = {
        modifyLastChar(text, transformFn) {
            const lastCharCode = text.charCodeAt(text.length - 1);
            // if (transformFn === bitFunctions.decrementLastChar1Bit && String.fromCharCode(lastCharCode) == 0) return text.slice(0, -1);  
            const newCharCode = transformFn(lastCharCode) & 0xFF; // & 0xFF to Keep it between 0â€“255
            const newChar = String.fromCharCode(newCharCode);
            return text.slice(0, -1) + newChar;
        },
        removeLastChar(text) {
            return text.slice(0, -1);
        },
        incrementLastChar1Bit(text, bits = 1) {
            return bitFunctions.modifyLastChar(text, code => (code + bits));
        },
        decrementLastChar1Bit(text, bits = 1) {
            return bitFunctions.modifyLastChar(text, code => (code - bits + 256));
        },
        shiftLastCharLeft1(text) {
            return bitFunctions.modifyLastChar(text, code => (code << 1));
        },
        shiftLastCharLeft1Add1(text) {
            return bitFunctions.modifyLastChar(text, code => ((code << 1) + 1));
        },
        shiftLastCharRight1(text) {
            return bitFunctions.modifyLastChar(text, code => (code >>> 1));
        },
        modifyInput(transformFn) {
            const input = document.getElementById("input");
            if (!input) return;

            const text = input.value;

            // decrement & increment on empty string sets to null character (00000000) so disable decrement
            if (transformFn === bitFunctions.decrementLastChar1Bit && (text.length === 0)) return;    
            // decrement on null character (00000000) will delete last character
            if (transformFn === bitFunctions.decrementLastChar1Bit && (text.charCodeAt(text.length - 1) == 0)){
                transformFn = bitFunctions.removeLastChar;
            } 

            const modifiedText = transformFn(text);
            input.value = modifiedText;
            input.oninput();
        },
        incrementInput() {
            bitFunctions.modifyInput(bitFunctions.incrementLastChar1Bit);
        },
        decrementInput() {
            bitFunctions.modifyInput(bitFunctions.decrementLastChar1Bit);
        },
        shiftInputLeft1() {
            bitFunctions.modifyInput(bitFunctions.shiftLastCharLeft1Add1);
        },
        shiftInputRight1() {
            bitFunctions.modifyInput(bitFunctions.shiftLastCharRight1);
        },
        incrementBinary1Bit() {
        },
        decrementBinary1Bit() {
        },
        shiftBinaryLeft1() {
            const textarea  = document.getElementById("inputBinary");
            const input = document.getElementById("input");
            if (!input) return;

            let value = textarea.value.trim();

            // Check if valid binary string (only 0s and 1s)
            if (!/^[01]+$/.test(value)) {
                console.error("Invalid binary string");
                return;
            }

            // Left shift by removing the first char and appending '0'
            const shifted = value.slice(1) + '0';

            textarea.value = shifted;

            // const lastCharCode = text.charCodeAt(text.length - 1);
            // const incrementedCharCode = (lastCharCode + 1) & 0xFF; // Wrap at 256
            // const newChar = String.fromCharCode(incrementedCharCode);

            // const newText = text.slice(0, -1) + newChar;
            // input.value = newText;

            // input.oninput();

            // Group the shifted binary string into 8-bit chunks
            let chars = '';
            for (let i = 0; i < shifted.length; i += 8) {
                const byte = shifted.slice(i, i + 8);
                if (byte.length === 8) {
                    const code = parseInt(byte, 2);
                    chars += String.fromCharCode(code);
                }
            }

            input.value = chars;
        },
        shiftBinaryRight1() {
        }
    };

    function preprocessMessage(text) {
        const encoder = new TextEncoder();
        let message = Array.from(encoder.encode(text));
        let bitLength = message.length * 8;
        
        if (document.getElementById('append1Bit') && document.getElementById('append1Bit').checked) {
            message.push(0x80);
        }

        if (document.getElementById('fill0Bit') && document.getElementById('fill0Bit').checked) {
            while ((message.length * 8 + 64) % 512 !== 0) {
                message.push(0);
            }
        }

        if (document.getElementById('appendLength') && document.getElementById('appendLength').checked) {
            //!!!bug warning!!! You might expect (bitLength >>> 32) & 0xff === 0 but the result is 8. In js, the shift operator >>> only works on the lower 32 bits of a number â€” the result is always a 32-bit unsigned integer.
            let high = Math.floor(bitLength / 2**32);
            let low = bitLength >>> 0;
            for (let i = 3; i >= 0; i--) {
                message.push((high >>> (i * 8)) & 0xff);
            }
            for (let i = 3; i >= 0; i--) {
                message.push((low >>> (i * 8)) & 0xff);
            }
        }

        return message;
    }

    function bitsToUint32(bitsArray){
        const ret = new Uint32;
        ret = (message[i * 4] << 24) | (message[i * 4 + 1] << 16) | (message[i * 4 + 2] << 8) | (message[i * 4 + 3]);
        return ret;
    }

    function processMessage(message) {
        const w = new Uint32Array(64);

        // convert message array to Uint32Array
        for (let i = 0; i < 16; i++) {
            w[i] = (message[i * 4] << 24) | (message[i * 4 + 1] << 16) | (message[i * 4 + 2] << 8) | (message[i * 4 + 3]);
        }

        // calculate w values 16-64
        for (let i = 16; i < 64; i++) {
            let s0 = rightRotate(w[i - 15], 7) ^ rightRotate(w[i - 15], 18) ^ (w[i - 15] >>> 3);
            let s1 = rightRotate(w[i - 2], 17) ^ rightRotate(w[i - 2], 19) ^ (w[i - 2] >>> 10);
            w[i] = (w[i - 16] + s0 + w[i - 7] + s1) >>> 0;
        }

        return w;
    }

    function Rounds0to63(w, outputToUI = true){
        const roundsTableBody = document.querySelector("#roundsLogTable tbody");
        
        const roundsCollapse = document.getElementById("roundsCollapseCheckbox").checked;
        const roundsCollapseStart = 2;
        const roundsCollapseEnd = 60;
        
        const fragment = document.createDocumentFragment();
        let previousHash = null; // global or outer variable to track previous state
        let initialHash = new Array(8).fill(0);;

        if (document.getElementById('initWorkingVars') && document.getElementById('initWorkingVars').checked) {
            initialHash = initialPrimes.slice();
        } 

        let hashArray = initialHash.slice();  // copy of initialHash
        let row = createRow(0, intArrayToStringArray(hashArray));
        fragment.appendChild(row);

        for (let i = 0; i < 64; i++) {
            let S1 = rightRotate(hashArray[4], 6) ^ rightRotate(hashArray[4], 11) ^ rightRotate(hashArray[4], 25);
            let ch = (hashArray[4] & hashArray[5]) ^ (~hashArray[4] & hashArray[6]);
            let temp1 = (hashArray[7] + S1 + ch + k[i] + w[i]) >>> 0;

            let S0 = rightRotate(hashArray[0], 2) ^ rightRotate(hashArray[0], 13) ^ rightRotate(hashArray[0], 22);
            let maj = (hashArray[0] & hashArray[1]) ^ (hashArray[0] & hashArray[2]) ^ (hashArray[1] & hashArray[2]);
            let temp2 = (S0 + maj) >>> 0;

            previousHash = hashArray.slice(); // make a copy for next round

            //calc new hashArray values. a & e change per round
            hashArray = [
                (temp1 + temp2) >>> 0, hashArray[0], hashArray[1], hashArray[2],
                (hashArray[3] + temp1) >>> 0, hashArray[4], hashArray[5], hashArray[6]
            ];

            row = createRow(i + 1, intArrayToStringArray(hashArray));
            
            //create differences cols
            if (previousHash !== null){
                let cellD = document.createElement("td");
                cellD.textContent = (hashArray[4] - previousHash[3]).toString(10);
                row.appendChild(cellD);
                
                let cellH = document.createElement("td");
                cellH.textContent = (hashArray[0] - previousHash[7]).toString(10);
                row.appendChild(cellH);
            }
            
            // if roundCollapse is checked then don't show rows
            if (roundsCollapse && i > roundsCollapseStart && i < roundsCollapseEnd) 
                continue;

            fragment.appendChild(row);
        }

        // Add initialHash values to hashArray before returning
        for (let i = 0; i < 8; i++) {
            hashArray[i] = (hashArray[i] + initialHash[i]) >>> 0;
        }

        row = createRow("", intArrayToStringArray(hashArray));
        fragment.appendChild(row);

        if (outputToUI) {   // output values to ui
            roundsTableBody.innerHTML = "";   // clear out old table tbody
            roundsTableBody.appendChild(fragment);
        }

        return hashArray;
    }

    async function manualSHA256(text, outputToUI = true) {
        const encoder = new TextEncoder();
        const message = preprocessMessage(text);
        const w = processMessage(message);

        if (outputToUI) {   // output values to ui
            const textMessage = Array.from(encoder.encode(text));
            document.getElementById('lengthDisplay').innerText = textMessage.length;
            document.getElementById('bitLengthDisplay').innerText = textMessage.length * 8;
            document.getElementById('inputBinary').value = byteArrayToBinaryStr(message.slice(0, textMessage.length));
            // document.getElementById('inputBinary').value = byteArrayToBinaryStr(message.slice(0, text.length));
            document.getElementById('messageBinaryPreprocessed').value = byteArrayToBinaryStr(message);
            document.getElementById('messageBinaryPreprocessed').value += "\n\n";
            document.getElementById('messageBinaryPreprocessed').value += printIntArrayAsBinaryStr(w.slice(16, 64));

            document.getElementById('messageW').value = printIntArray(w.slice(0, 16));
            document.getElementById('messageW').value += "\n\n";
            document.getElementById('messageW').value += printIntArray(w.slice(16, 64));
        }

        let hashArray = Rounds0to63(w, outputToUI);  

        // const hashHexStr = hashArray.map(h => h.toString(16).padStart(8, '0')).join('');
        const hashBytesArray = int32ArrayToBytesArray(hashArray);
        return hashBytesArray;
    }

    async function apiSHA256(text) {
        const encoder = new TextEncoder();
        const data = encoder.encode(text);
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        const hashArray = new Uint8Array(hashBuffer);
        const hashJSArray = Array.from(hashArray);      // convert to JS array

        // const hashHexStr = Array.from(hashArray).map(byte => byte.toString(16).padStart(2, '0')).join('');
        return hashJSArray;
    }

    async function generateHash() {
        const encoder = new TextEncoder();
        const incrementTableBody = document.querySelector("#incrementTable tbody");
        const showAPI = document.getElementById('APICheckbox').checked;
        const displayFormat = document.getElementById('displayFormat').value;

        const NUM_INCREMENTS = 4;
        const fragment = document.createDocumentFragment();
        let previousManualHashArray = "";

        let text = document.getElementById('input').value;
        
        for (let i = 1; i <= NUM_INCREMENTS; i++) {
            const manualHashArray = (i == 1) ? await manualSHA256(text, true) : await manualSHA256(text, false);  // don't output after first 
            const cryptoHashArray = await apiSHA256(text);

            const manualHashHexStr = formatByteArray(manualHashArray, displayFormat);
            const cryptoHashHexStr = formatByteArray(cryptoHashArray, displayFormat);
            
            // document.getElementById('manualSHA').innerText = manualHash;
            // document.getElementById("cryptoSHA").innerText = cryptoHash;

            if (previousManualHashArray !== ""){
                const { diffArray, totalDiffBits } = bitDifference(previousManualHashArray, manualHashArray);
                const diffArrayHexStr = formatByteArray(diffArray, displayFormat);
                // const rowDiff = createRow(totalDiffBits, [diffArrayHexStr]);
                const rowDiff = createRow("", [totalDiffBits.toString(), diffArrayHexStr]);
                fragment.appendChild(rowDiff);
            }

            // const row = (showAPI) ? createRow(messageBinary, ["", manualHashHexStr, cryptoHashHexStr]) : createRow(messageBinary, ["", manualHashHexStr]);

            // binary header
            const header = byteArrayToBinaryStr(Array.from(encoder.encode(text)));
            // const header = text.charCodeAt(text.length - 1);
            const row = (showAPI) ? createRow(header, ["", manualHashHexStr, cryptoHashHexStr]) : createRow(header, ["", manualHashHexStr]);
            fragment.appendChild(row);

            previousManualHashArray = manualHashArray;
            text = bitFunctions.incrementLastChar1Bit(text, 1);
            // text = bitFunctions.shiftLastCharLeft1Add1(text, 1);
        }

        incrementTableBody.innerHTML = "";  // clear out old table tbody
        incrementTableBody.appendChild(fragment);
    }

    window.addEventListener('load', generateHash);

    //show/hide based on checkbox values
    // window.addEventListener("load", () => toggleVisibilityByID('cryptoSHAContainer', document.getElementById("showCrypto").checked));
    window.addEventListener("load", () => toggleDisplayByID('roundsContainer', document.getElementById("roundsShowCheckbox").checked));
    window.addEventListener("load", () => toggleDisplayByID('incrementContainer', document.getElementById("incrementCheckbox").checked));
    window.addEventListener("load", () => toggleDisplayTableIDCol('incrementTable', 4, document.getElementById("APICheckbox").checked));

    document.addEventListener('wheel', (e) => {
        e.preventDefault();                     // prevent page scroll

        if (e.deltaY < 0) {
            bitFunctions.incrementInput();      // Scroll wheel UP anywhere on page
        } else if (e.deltaY > 0) {
            bitFunctions.decrementInput();      // Scroll wheel DOWN anywhere on page
        }
    }, { passive: false });  // ðŸ‘ˆðŸ‘ˆ Required to allow preventDefault!
    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') {
            e.preventDefault();
            bitFunctions.shiftInputLeft1();
        } else if (e.key === 'ArrowRight') {
            e.preventDefault();
            bitFunctions.shiftInputRight1();
        } else if (e.key === 'Backspace') {
            const input = document.getElementById('input');

            // Only act if input is not focused (optional, if you want to override default)
            if (document.activeElement !== input) {
                e.preventDefault(); // Prevent browser navigation
                input.value = input.value.slice(0, -1); // Remove last character
                generateHash();
            }
        }
    });
</script>
</html>
